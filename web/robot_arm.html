<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GestuBot - 3D Robot Arm Control</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #fff;
            overflow: hidden;
            height: 100vh;
        }
        
        #canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        /* HUD Overlay */
        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 12px;
            padding: 20px;
            min-width: 280px;
        }
        
        .hud h1 {
            font-size: 1.4rem;
            font-weight: 600;
            color: #00ff88;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .hud h1::before {
            content: '';
            display: block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #00ff88;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; box-shadow: 0 0 10px #00ff88; }
            50% { opacity: 0.5; box-shadow: 0 0 5px #00ff88; }
        }
        
        .status-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .status-row:last-child {
            border-bottom: none;
        }
        
        .label {
            color: #888;
            font-size: 0.85rem;
        }
        
        .value {
            font-weight: 600;
            font-size: 0.95rem;
        }
        
        .value.connected { color: #00ff88; }
        .value.disconnected { color: #ff4444; }
        .value.gesture { color: #00d4ff; }
        
        /* Connection status indicator */
        #connection-status {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            z-index: 100;
        }
        
        #connection-status.connected {
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
            color: #00ff88;
        }
        
        #connection-status.disconnected {
            background: rgba(255, 68, 68, 0.2);
            border: 1px solid #ff4444;
            color: #ff4444;
        }
        
        /* Gesture display */
        .gesture-display {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 100;
        }
        
        .gesture-icon {
            font-size: 4rem;
            margin-bottom: 10px;
            filter: drop-shadow(0 0 20px rgba(0, 212, 255, 0.5));
            transition: transform 0.2s ease;
        }
        
        .gesture-icon.active {
            transform: scale(1.1);
        }
        
        .gesture-name {
            font-size: 1.5rem;
            font-weight: 600;
            color: #00d4ff;
            text-transform: uppercase;
            letter-spacing: 3px;
        }
        
        /* Instructions panel */
        .instructions {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 15px;
            font-size: 0.8rem;
            color: #888;
            z-index: 100;
        }
        
        .instructions h3 {
            color: #fff;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }
        
        .instructions ul {
            list-style: none;
        }
        
        .instructions li {
            padding: 3px 0;
        }
        
        .instructions .key {
            display: inline-block;
            background: rgba(0, 212, 255, 0.2);
            color: #00d4ff;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: 600;
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <!-- HUD -->
    <div class="hud">
        <h1>GestuBot Control</h1>
        <div class="status-row">
            <span class="label">Connection</span>
            <span class="value" id="ws-status">Connecting...</span>
        </div>
        <div class="status-row">
            <span class="label">Current Gesture</span>
            <span class="value gesture" id="current-gesture">-</span>
        </div>
        <div class="status-row">
            <span class="label">Arm Position</span>
            <span class="value" id="arm-position">Reset</span>
        </div>
        <div class="status-row">
            <span class="label">Gripper</span>
            <span class="value" id="gripper-status">Open</span>
        </div>
    </div>
    
    <!-- Connection indicator -->
    <div id="connection-status" class="disconnected">‚óè Disconnected</div>
    
    <!-- Gesture display -->
    <div class="gesture-display">
        <div class="gesture-icon" id="gesture-icon">‚úä</div>
        <div class="gesture-name" id="gesture-name">Waiting...</div>
    </div>
    
    <!-- Instructions -->
    <div class="instructions">
        <h3>Gesture Controls</h3>
        <ul>
            <li><span class="key">‚úä</span> Fist ‚Üí Reset</li>
            <li><span class="key">üñê</span> Palm ‚Üí Extend</li>
            <li><span class="key">üëà</span> Left ‚Üí Rotate L</li>
            <li><span class="key">üëâ</span> Right ‚Üí Rotate R</li>
            <li><span class="key">‚úå</span> V-Sign ‚Üí Grip</li>
        </ul>
    </div>
    
    <!-- Three.js from CDN (free) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // =================================================================
        // THREE.JS ROBOT ARM SETUP
        // =================================================================
        
        let scene, camera, renderer;
        let robotArm = {};
        let targetRotation = { base: 0, shoulder: 0, elbow: 0, gripper: 0 };
        let currentRotation = { base: 0, shoulder: 0, elbow: 0, gripper: 0 };
        let isGripperClosed = false;
        
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            
            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 4, 8);
            camera.lookAt(0, 2, 0);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            const mainLight = new THREE.DirectionalLight(0xffffff, 1);
            mainLight.position.set(5, 10, 5);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            scene.add(mainLight);
            
            const accentLight = new THREE.PointLight(0x00ff88, 0.5, 20);
            accentLight.position.set(-3, 5, 3);
            scene.add(accentLight);
            
            // Ground
            const groundGeometry = new THREE.PlaneGeometry(20, 20);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x111111,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Grid
            const grid = new THREE.GridHelper(20, 20, 0x00ff88, 0x222222);
            grid.position.y = 0.01;
            scene.add(grid);
            
            // Build robot arm
            createRobotArm();
            
            // Handle resize
            window.addEventListener('resize', onWindowResize);
            
            // Start animation
            animate();
        }
        
        function createRobotArm() {
            const metalMaterial = new THREE.MeshStandardMaterial({
                color: 0x444444,
                roughness: 0.3,
                metalness: 0.8
            });
            
            const accentMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ff88,
                roughness: 0.2,
                metalness: 0.9,
                emissive: 0x00ff88,
                emissiveIntensity: 0.2
            });
            
            const jointMaterial = new THREE.MeshStandardMaterial({
                color: 0x00d4ff,
                roughness: 0.2,
                metalness: 0.9,
                emissive: 0x00d4ff,
                emissiveIntensity: 0.3
            });
            
            // Base (rotating platform)
            robotArm.base = new THREE.Group();
            scene.add(robotArm.base);
            
            const baseGeometry = new THREE.CylinderGeometry(1, 1.2, 0.3, 32);
            const baseMesh = new THREE.Mesh(baseGeometry, accentMaterial);
            baseMesh.position.y = 0.15;
            baseMesh.castShadow = true;
            robotArm.base.add(baseMesh);
            
            // Lower arm
            robotArm.shoulder = new THREE.Group();
            robotArm.shoulder.position.y = 0.3;
            robotArm.base.add(robotArm.shoulder);
            
            const shoulderJoint = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 32, 32),
                jointMaterial
            );
            shoulderJoint.castShadow = true;
            robotArm.shoulder.add(shoulderJoint);
            
            const lowerArm = new THREE.Mesh(
                new THREE.BoxGeometry(0.4, 2, 0.4),
                metalMaterial
            );
            lowerArm.position.y = 1;
            lowerArm.castShadow = true;
            robotArm.shoulder.add(lowerArm);
            
            // Upper arm (with elbow)
            robotArm.elbow = new THREE.Group();
            robotArm.elbow.position.y = 2;
            robotArm.shoulder.add(robotArm.elbow);
            
            const elbowJoint = new THREE.Mesh(
                new THREE.SphereGeometry(0.25, 32, 32),
                jointMaterial
            );
            elbowJoint.castShadow = true;
            robotArm.elbow.add(elbowJoint);
            
            const upperArm = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 1.5, 0.3),
                metalMaterial
            );
            upperArm.position.y = 0.75;
            upperArm.castShadow = true;
            robotArm.elbow.add(upperArm);
            
            // Wrist/Gripper assembly
            robotArm.wrist = new THREE.Group();
            robotArm.wrist.position.y = 1.5;
            robotArm.elbow.add(robotArm.wrist);
            
            const wristJoint = new THREE.Mesh(
                new THREE.SphereGeometry(0.15, 32, 32),
                jointMaterial
            );
            wristJoint.castShadow = true;
            robotArm.wrist.add(wristJoint);
            
            // Gripper fingers
            robotArm.gripperLeft = new THREE.Mesh(
                new THREE.BoxGeometry(0.08, 0.4, 0.15),
                accentMaterial
            );
            robotArm.gripperLeft.position.set(-0.15, 0.3, 0);
            robotArm.gripperLeft.castShadow = true;
            robotArm.wrist.add(robotArm.gripperLeft);
            
            robotArm.gripperRight = new THREE.Mesh(
                new THREE.BoxGeometry(0.08, 0.4, 0.15),
                accentMaterial
            );
            robotArm.gripperRight.position.set(0.15, 0.3, 0);
            robotArm.gripperRight.castShadow = true;
            robotArm.wrist.add(robotArm.gripperRight);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Smooth interpolation towards target positions
            const lerpSpeed = 0.08;
            
            currentRotation.base += (targetRotation.base - currentRotation.base) * lerpSpeed;
            currentRotation.shoulder += (targetRotation.shoulder - currentRotation.shoulder) * lerpSpeed;
            currentRotation.elbow += (targetRotation.elbow - currentRotation.elbow) * lerpSpeed;
            currentRotation.gripper += (targetRotation.gripper - currentRotation.gripper) * lerpSpeed;
            
            // Apply rotations
            robotArm.base.rotation.y = currentRotation.base;
            robotArm.shoulder.rotation.z = currentRotation.shoulder;
            robotArm.elbow.rotation.z = currentRotation.elbow;
            
            // Gripper animation
            const gripperOffset = currentRotation.gripper * 0.1;
            robotArm.gripperLeft.position.x = -0.15 + gripperOffset;
            robotArm.gripperRight.position.x = 0.15 - gripperOffset;
            
            renderer.render(scene, camera);
        }
        
        // =================================================================
        // GESTURE HANDLING
        // =================================================================
        
        const gestureIcons = {
            0: '‚úä', // Fist
            1: 'üñêÔ∏è', // Open Palm
            2: 'üëà', // Point Left
            3: 'üëâ', // Point Right
            4: '‚úåÔ∏è', // V-Sign
            5: '‚¨ú'  // Background
        };
        
        const gestureNames = {
            0: 'Fist - Reset',
            1: 'Palm - Extend',
            2: 'Left - Rotate L',
            3: 'Right - Rotate R',
            4: 'V-Sign - Grip',
            5: 'No Hand'
        };
        
        function handleGesture(gestureClass) {
            // Update UI
            document.getElementById('gesture-icon').textContent = gestureIcons[gestureClass] || '‚ùì';
            document.getElementById('gesture-name').textContent = gestureNames[gestureClass] || 'Unknown';
            document.getElementById('current-gesture').textContent = gestureNames[gestureClass] || '-';
            
            // Animate icon
            const icon = document.getElementById('gesture-icon');
            icon.classList.add('active');
            setTimeout(() => icon.classList.remove('active'), 200);
            
            // Apply gesture to robot
            switch (gestureClass) {
                case 0: // Fist - Reset
                    targetRotation.base = 0;
                    targetRotation.shoulder = 0;
                    targetRotation.elbow = 0;
                    document.getElementById('arm-position').textContent = 'Reset';
                    break;
                    
                case 1: // Open Palm - Extend forward
                    targetRotation.shoulder = -0.5;
                    targetRotation.elbow = 0.8;
                    document.getElementById('arm-position').textContent = 'Extended';
                    break;
                    
                case 2: // Point Left - Rotate left
                    targetRotation.base += 0.15;
                    targetRotation.base = Math.min(targetRotation.base, Math.PI * 0.75);
                    document.getElementById('arm-position').textContent = 'Rotating Left';
                    break;
                    
                case 3: // Point Right - Rotate right
                    targetRotation.base -= 0.15;
                    targetRotation.base = Math.max(targetRotation.base, -Math.PI * 0.75);
                    document.getElementById('arm-position').textContent = 'Rotating Right';
                    break;
                    
                case 4: // V-Sign - Toggle gripper
                    isGripperClosed = !isGripperClosed;
                    targetRotation.gripper = isGripperClosed ? 1 : 0;
                    document.getElementById('gripper-status').textContent = isGripperClosed ? 'Closed' : 'Open';
                    break;
                    
                case 5: // Background - Idle
                    document.getElementById('arm-position').textContent = 'Idle';
                    break;
            }
        }
        
        // =================================================================
        // WEBSOCKET CONNECTION
        // =================================================================
        
        let ws = null;
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 10;
        
        function connectWebSocket() {
            ws = new WebSocket('ws://localhost:8765');
            
            ws.onopen = () => {
                console.log('[WS] Connected to GestuBot');
                reconnectAttempts = 0;
                updateConnectionStatus(true);
            };
            
            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    if (data.type === 'gesture') {
                        handleGesture(data.class);
                    }
                } catch (e) {
                    console.error('[WS] Parse error:', e);
                }
            };
            
            ws.onclose = () => {
                console.log('[WS] Disconnected');
                updateConnectionStatus(false);
                
                // Attempt reconnect
                if (reconnectAttempts < maxReconnectAttempts) {
                    reconnectAttempts++;
                    console.log(`[WS] Reconnecting (attempt ${reconnectAttempts})...`);
                    setTimeout(connectWebSocket, 2000);
                }
            };
            
            ws.onerror = (error) => {
                console.error('[WS] Error:', error);
            };
        }
        
        function updateConnectionStatus(connected) {
            const statusEl = document.getElementById('connection-status');
            const wsStatusEl = document.getElementById('ws-status');
            
            if (connected) {
                statusEl.className = 'connected';
                statusEl.textContent = '‚óè Connected';
                wsStatusEl.className = 'value connected';
                wsStatusEl.textContent = 'Active';
            } else {
                statusEl.className = 'disconnected';
                statusEl.textContent = '‚óè Disconnected';
                wsStatusEl.className = 'value disconnected';
                wsStatusEl.textContent = 'Offline';
            }
        }
        
        // =================================================================
        // KEYBOARD FALLBACK (for testing without gestures)
        // =================================================================
        
        document.addEventListener('keydown', (e) => {
            switch (e.key) {
                case '0': handleGesture(0); break;
                case '1': handleGesture(1); break;
                case '2': handleGesture(2); break;
                case '3': handleGesture(3); break;
                case '4': handleGesture(4); break;
                case '5': handleGesture(5); break;
            }
        });
        
        // =================================================================
        // INITIALIZATION
        // =================================================================
        
        init();
        connectWebSocket();
    </script>
</body>
</html>
